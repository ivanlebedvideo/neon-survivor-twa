<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Survivor - Multi-Touch Edition</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: sans-serif; overflow: hidden; touch-action: none; }
        #ui { position: absolute; top: 10px; left: 10px; z-index: 10; pointer-events: none; }
        .stat { font-size: 13px; color: #4ecca3; margin-bottom: 2px; }
        
        #menu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: rgba(0,0,0,0.95); z-index: 100; padding: 20px; box-sizing: border-box; }
        .menu-box { background: #16213e; padding: 25px; border: 2px solid #e94560; border-radius: 15px; width: 100%; max-width: 300px; text-align: center; }
        
        .setting { margin: 12px 0; text-align: left; }
        .setting label { font-size: 10px; color: #4ecca3; display: block; margin-bottom: 4px; }
        .val { float: right; color: #f9ca24; font-weight: bold; }
        
        input[type=range] { width: 100%; accent-color: #e94560; }
        #startBtn { background: #e94560; color: white; border: none; padding: 15px; width: 100%; font-size: 18px; font-weight: bold; border-radius: 10px; margin-top: 15px; cursor: pointer; }

        #joyBound { position: absolute; width: 100px; height: 100px; background: rgba(255,255,255,0.05); border-radius: 50%; border: 1px solid rgba(78, 204, 163, 0.3); display: none; pointer-events: none; transform: translate(-50%, -50%); }
        #joyStick { position: absolute; top: 50%; left: 50%; width: 40px; height: 40px; background: #4ecca3; border-radius: 50%; transform: translate(-50%, -50%); }

        #levelUp { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #16213e; padding: 20px; border: 2px solid #e94560; border-radius: 15px; display: none; z-index: 200; width: 80%; text-align: center; }
        .card { background: #0f3460; padding: 12px; margin: 8px 0; border-radius: 8px; border: 1px solid #30475e; font-weight: bold; }
    </style>
</head>
<body>
    <div id="menu">
        <div class="menu-box">
            <h2 style="color: #e94560; margin: 0 0 15px 0;">NEON SURVIVOR</h2>
            <div class="setting"><label>XP MULT <span id="xpVal" class="val">x2</span></label><input type="range" id="xpSlider" min="1" max="10" value="2"></div>
            <div class="setting"><label>SPAWN <span id="spawnVal" class="val">x1</span></label><input type="range" id="spawnSlider" min="1" max="5" value="1" step="0.5"></div>
            <button id="startBtn">START MISSION</button>
        </div>
    </div>

    <div id="ui">
        <div class="stat">HP: <span id="hp">100</span> | LVL: <span id="lvl">1</span></div>
        <div class="stat">EXP: <span id="exp">0</span>/<span id="expNeeded">100</span></div>
    </div>

    <div id="joyBound"><div id="joyStick"></div></div>
    <div id="levelUp"><h3 style="color: #e94560">CHOOSE POWER</h3><div id="options"></div></div>

    <script type="importmap">{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }</script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        const tg = window.Telegram.WebApp; tg.expand(); tg.ready();

        let audioCtx; 
        function playSfx(type) {
            if (!audioCtx || audioCtx.state === 'suspended') return;
            const o = audioCtx.createOscillator(), g = audioCtx.createGain();
            o.type = (type === 'explosion') ? 'sawtooth' : 'triangle';
            o.frequency.setValueAtTime(type === 'explosion' ? 120 : 600, audioCtx.currentTime);
            g.gain.setValueAtTime(0.04, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
            o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + 0.1);
        }

        const scene = new THREE.Scene(); scene.fog = new THREE.FogExp2(0x000000, 0.03);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.6, 0.4, 0.85));
        composer.addPass(new OutputPass());

        scene.add(new THREE.GridHelper(1000, 80, 0x16213e, 0x050505));

        const game = { active: false, paused: false, xpMult: 2, spawnMult: 1 };
        const player = {
            group: new THREE.Group(), hp: 100, level: 1, exp: 0, expNeeded: 100, speed: 0.15, fireRate: 600, lastShot: 0, damage: 30, pierce: 0, shieldLvl: 0, shields: []
        };
        const pMesh = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1.2, 4), new THREE.MeshStandardMaterial({ color: 0x4ecca3, emissive: 0x4ecca3, emissiveIntensity: 2 }));
        pMesh.rotation.x = Math.PI/2; player.group.add(pMesh); scene.add(player.group);
        const light = new THREE.PointLight(0x4ecca3, 40, 20); scene.add(light);

        let yaw = 0, pitch = 0.6;
        const enemies = [], bullets = [], orbs = [], particles = [];

        // --- MULTI-TOUCH ENGINE ---
        let moveTouchId = null, camTouchId = null;
        let joyStart = { x: 0, y: 0 }, joyVec = { x: 0, y: 0 };
        let camLast = { x: 0, y: 0 };

        document.addEventListener('touchstart', (e) => {
            if (!game.active || game.paused) return;
            for (let t of e.changedTouches) {
                if (t.clientX < window.innerWidth / 2 && moveTouchId === null) {
                    moveTouchId = t.identifier;
                    joyStart = { x: t.clientX, y: t.clientY };
                    const jb = document.getElementById('joyBound');
                    jb.style.display = 'block'; jb.style.left = t.clientX + 'px'; jb.style.top = t.clientY + 'px';
                } else if (camTouchId === null) {
                    camTouchId = t.identifier;
                    camLast = { x: t.clientX, y: t.clientY };
                }
            }
        }, {passive: false});

        document.addEventListener('touchmove', (e) => {
            if (!game.active || game.paused) return;
            for (let t of e.changedTouches) {
                if (t.identifier === moveTouchId) {
                    const dx = t.clientX - joyStart.x, dy = t.clientY - joyStart.y;
                    const dist = Math.min(50, Math.sqrt(dx*dx + dy*dy));
                    const ang = Math.atan2(dy, dx);
                    joyVec = { x: Math.cos(ang) * (dist/50), y: Math.sin(ang) * (dist/50) };
                    document.getElementById('joyStick').style.left = `calc(50% + ${joyVec.x * 35}px)`;
                    document.getElementById('joyStick').style.top = `calc(50% + ${joyVec.y * 35}px)`;
                } else if (t.identifier === camTouchId) {
                    const dx = t.clientX - camLast.x, dy = t.clientY - camLast.y;
                    yaw -= dx * 0.007; pitch = Math.max(-0.2, Math.min(1.1, pitch + dy * 0.007));
                    camLast = { x: t.clientX, y: t.clientY };
                }
            }
        }, {passive: false});

        document.addEventListener('touchend', (e) => {
            for (let t of e.changedTouches) {
                if (t.identifier === moveTouchId) {
                    moveTouchId = null; joyVec = { x: 0, y: 0 };
                    document.getElementById('joyBound').style.display = 'none';
                } else if (t.identifier === camTouchId) {
                    camTouchId = null;
                }
            }
        });

        // --- UPGRADES & SHIELDS ---
        function updateShields() {
            player.shields.forEach(s => scene.remove(s)); player.shields = [];
            for(let i=0; i<player.shieldLvl; i++) {
                const s = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.1, 0.4), new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 3 }));
                scene.add(s); player.shields.push(s);
            }
        }

        function createExplosion(pos) {
            playSfx('explosion');
            for(let i=0; i<10; i++) {
                const p = new THREE.Mesh(new THREE.SphereGeometry(0.12), new THREE.MeshBasicMaterial({ color: 0xe94560 }));
                p.position.copy(pos); p.vel = new THREE.Vector3((Math.random()-0.5)*0.5, Math.random()*0.5, (Math.random()-0.5)*0.5);
                p.life = 1.0; scene.add(p); particles.push(p);
            }
        }

        function levelUp() {
            game.paused = true; player.exp -= player.expNeeded; player.expNeeded *= 1.4; player.level++;
            document.getElementById('levelUp').style.display = 'block';
            const ops = document.getElementById('options'); ops.innerHTML = '';
            const pool = [
                {n:'Damage+', f:()=>player.damage+=15}, {n:'Rate+', f:()=>player.fireRate*=0.85},
                {n:'Pierce+', f:()=>player.pierce++}, {n:'Shield+', f:()=>{player.shieldLvl++; updateShields();}}
            ];
            pool.sort(()=>0.5-Math.random()).slice(0,3).forEach(u => {
                const c = document.createElement('div'); c.className = 'card'; c.innerText = u.n;
                c.onclick = () => { u.f(); document.getElementById('levelUp').style.display='none'; game.paused=false; };
                ops.appendChild(c);
            });
        }

        // --- START ---
        document.getElementById('startBtn').onclick = () => {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            game.active = true; document.getElementById('menu').style.display = 'none';
            game.xpMult = parseFloat(document.getElementById('xpSlider').value);
            game.spawnMult = parseFloat(document.getElementById('spawnSlider').value);
        };

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            if (game.active && !game.paused) {
                player.group.rotation.y = yaw;
                if (joyVec.x !== 0 || joyVec.y !== 0) {
                    const mv = new THREE.Vector3(joyVec.x, 0, joyVec.y).applyQuaternion(player.group.quaternion).multiplyScalar(player.speed);
                    player.group.position.add(mv);
                }

                // Shields
                player.shields.forEach((s, i) => {
                    const a = time * 3 + (i / player.shields.length) * Math.PI * 2;
                    s.position.set(player.group.position.x + Math.cos(a)*3, 0.6, player.group.position.z + Math.sin(a)*3);
                    s.rotation.y = -a;
                    for(let j=enemies.length-1; j>=0; j--) {
                        if(s.position.distanceTo(enemies[j].position) < 1.5) {
                            enemies[j].hp -= 1.2; if(enemies[j].hp <= 0) { createExplosion(enemies[j].position); scene.remove(enemies[j]); enemies.splice(j, 1); }
                        }
                    }
                });

                // Shooting
                if (Date.now() - player.lastShot > player.fireRate && enemies.length > 0) {
                    let target = enemies[0];
                    const b = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                    b.position.copy(player.group.position);
                    b.vel = new THREE.Vector3().subVectors(target.position, b.position).normalize().multiplyScalar(0.7);
                    b.hits = []; scene.add(b); bullets.push(b); playSfx('shot'); player.lastShot = Date.now();
                }

                // Bullets
                for(let i=bullets.length-1; i>=0; i--) {
                    bullets[i].position.add(bullets[i].vel);
                    if(bullets[i].position.distanceTo(player.group.position) > 40) { scene.remove(bullets[i]); bullets.splice(i, 1); continue; }
                    for(let j=enemies.length-1; j>=0; j--) {
                        if(bullets[i].position.distanceTo(enemies[j].position) < 1.3 && !bullets[i].hits.includes(enemies[j])) {
                            enemies[j].hp -= player.damage; bullets[i].hits.push(enemies[j]);
                            if(enemies[j].hp <= 0) {
                                createExplosion(enemies[j].position);
                                const o = new THREE.Mesh(new THREE.OctahedronGeometry(0.3), new THREE.MeshBasicMaterial({ color: 0xf9ca24 }));
                                o.position.copy(enemies[j].position); scene.add(o); orbs.push(o);
                                scene.remove(enemies[j]); enemies.splice(j, 1);
                            }
                            if(bullets[i].hits.length > player.pierce) { scene.remove(bullets[i]); bullets.splice(i, 1); break; }
                        }
                    }
                }

                // Particles
                for(let i=particles.length-1; i>=0; i--) {
                    particles[i].position.add(particles[i].vel); particles[i].life -= 0.03; particles[i].scale.setScalar(particles[i].life);
                    if(particles[i].life <= 0) { scene.remove(particles[i]); particles.splice(i, 1); }
                }

                // Gems & Spawn
                for(let i=orbs.length-1; i>=0; i--) {
                    if(orbs[i].position.distanceTo(player.group.position) < 8) {
                        orbs[i].position.lerp(player.group.position, 0.2);
                        if(orbs[i].position.distanceTo(player.group.position) < 1.1) {
                            player.exp += 20 * game.xpMult; if(player.exp >= player.expNeeded) levelUp();
                            scene.remove(orbs[i]); orbs.splice(i, 1);
                        }
                    }
                }

                if(Math.random() < 0.01 * game.spawnMult) {
                    const a = Math.random()*Math.PI*2;
                    const e = new THREE.Mesh(new THREE.DodecahedronGeometry(0.6), new THREE.MeshStandardMaterial({ color: 0xe94560, emissive: 0xe94560 }));
                    e.position.set(player.group.position.x+Math.cos(a)*35, 0.6, player.group.position.z+Math.sin(a)*35);
                    e.hp = 30 + player.level*5; scene.add(e); enemies.push(e);
                }
                enemies.forEach(e => e.position.add(new THREE.Vector3().subVectors(player.group.position, e.position).normalize().multiplyScalar(0.06)));
            }

            const camD = 10;
            camera.position.set(player.group.position.x + Math.sin(yaw)*camD*Math.cos(pitch), player.group.position.y + Math.sin(pitch)*camD + 4, player.group.position.z + Math.cos(yaw)*camD*Math.cos(pitch));
            camera.lookAt(player.group.position.clone().add(new THREE.Vector3(0, 1.5, 0)));
            light.position.copy(player.group.position).y = 3;
            document.getElementById('hp').innerText = Math.floor(player.hp);
            document.getElementById('lvl').innerText = player.level;
            composer.render();
        }
        animate();
    </script>
</body>
</html>
